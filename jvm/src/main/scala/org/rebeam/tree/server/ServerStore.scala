package org.rebeam.tree.server

import io.circe.syntax._
import org.rebeam.tree.Delta
import org.rebeam.tree.server.util._
import org.rebeam.tree.sync.ServerStoreUpdate
import org.rebeam.tree.sync.ServerStoreUpdate._
import org.rebeam.tree.sync.Sync._

import scalaz.Scalaz._

import cats.data.Xor

import org.http4s.websocket.WebsocketBits.WebSocketFrame

import scalaz.concurrent.Task
import scalaz.stream.{Exchange, Process, Sink}

import org.http4s.websocket.WebsocketBits._

import io.circe._
import io.circe.parser._

/**
  * Stores a model, and allows that model to be updated (mutated) by
  * providing ServerDeltas, assigning ModelIds to . Can be observed to receive a firstUpdate with
  * the model
  * @param initialModel   The initial model for the store
  * @tparam A             The type of model in the store
  */
class ServerStore[A: ModelIdGen](initialModel: A) {

  private var nextId: Long = 0
  private var m: ModelAndId[A] = ModelAndId(initialModel, makeId(initialModel))
  private val lock = Lock()
  private val observers = new WeakHashSet[Observer[ServerStoreUpdate[A]]]()

  private def makeId(model: A): ModelId = {
    val mId = implicitly[ModelIdGen[A]].genId(initialModel).getOrElse(ModelId(nextId))
    nextId = nextId + 1
    mId
  }

  def applyDelta(d: DeltaWithIJ[A]): Unit = lock {
    val baseModelId = m.id
    val newModel = d.delta.apply(m.model)
    val newId = makeId(newModel)
    m = ModelAndId(newModel, newId)
    observers.foreach(_.observe(ServerStoreIncrementalUpdate(baseModelId, Vector(d), newId)))
  }

  def observe(o: Observer[ServerStoreUpdate[A]]): Unit = lock {
    observers.add(o)
    o.observe(ServerStoreFullUpdate(m))
  }

  def unobserve(o: Observer[ServerStoreUpdate[A]]): Unit = lock{
    observers.remove(o)
  }

}

/**
  * Uses DeltaWithIJs encoded as JSON for incoming messages, and ModelUpdates encoded to JSON for
  * outgoing messages.
  */
private class ServerStoreValueDispatcher[T](val store: ServerStore[T], val clientId: ClientId)(implicit encoder: Encoder[T], deltaDecoder: Decoder[Delta[T]]) extends Dispatcher[ServerStoreUpdate[T], Json, Json] {

  var pendingUpdateToClient = none[ServerStoreUpdate[T]]

  //Store pending update
  override def modelUpdated(update: ServerStoreUpdate[T]): Unit = {
    pendingUpdateToClient = Some(update)
  }

  //Clear pending update. If we had a value, write it as JSON
  override def msgForClient(): Option[Json] = {
    val update = pendingUpdateToClient
    pendingUpdateToClient = None

    //Convert update to Json for client
    update.map {

      case ServerStoreFullUpdate(modelAndId) =>
        Json.obj(
          "full" -> Json.obj(
            "model" -> encoder(modelAndId.model),
            "id" -> modelAndId.id.asJson
          )
        )

      case ServerStoreIncrementalUpdate(baseModelId, updates, updatedModelId) =>

        // Convert updates to Json, "compressing" by encoding local deltas
        // that were generated by this client into just the DeltaId
        val updatesJs = updates.map(
          d => if (d.id.clientId == clientId) {
            Json.obj(
              "local" -> d.id.asJson
            )
          } else {
            Json.obj(
              "remote" -> Json.obj(
                "delta" -> d.deltaJs,
                "id" -> d.id.asJson
              )
            )
          }
        )

        Json.obj(
          "inc" -> Json.obj(
            "baseModelId" -> baseModelId.asJson,
            "updatedModelId" -> updatedModelId.asJson,
            "updates" -> Json.arr(updatesJs: _*)
          )
        )
    }

  }

  //Expect incoming messages to be {"commit": {"delta": delta, "id": deltaId}}
  //where delta is Delta[T] to be decoded by deltaDecoder, and deltaId is a DeltaId[T]
  val clientMsgDecoder: Decoder[DeltaWithIJ[T]] = Decoder.instance(c => {

    val o = c.downField("commit")

    // We want to try to get the actual Json in the delta field value, this
    // leads to some rather convoluted code
    val d: Decoder.Result[Json] = o.downField("delta").focus
      .map(Xor.right[DecodingFailure, Json])
      .getOrElse(Xor.left[DecodingFailure, Json](DecodingFailure("Expected a delta field in commit object", o.history)))

    for {
      delta <- o.downField("delta").as[Delta[T]]
      id <- o.downField("id").as[DeltaId]
      deltaJs <- d
    } yield DeltaWithIJ(delta, id, deltaJs)
  })

  //Read the Js.Value as a delta, and apply it to the store
  override def msgFromClient(msg: Json): Unit = {
    val empty = msg.asObject.exists(_.fields.isEmpty)
    if (empty) {
      println("Pong!")
    } else {

      val deltaWithIJ = clientMsgDecoder.decodeJson(msg)
      println("Got client msg committing: " + deltaWithIJ)
      //TODO a bit messy using map just for side effect?
      deltaWithIJ.map(store.applyDelta)
    }
  }
}

object ServerStoreValueExchange {
  def apply[M](store: ServerStore[M], clientId: ClientId)(implicit encoder: Encoder[M], decoder: Decoder[M], deltaDecoder: Decoder[Delta[M]]): Exchange[WebSocketFrame, WebSocketFrame] = {

    val dispatcher = new ServerStoreValueDispatcher(store, clientId)
    val observer = new DispatchObserver(dispatcher)
    store.observe(observer)

    //Treat received text as JSON encoded deltas to data, if valid
    val sink: Sink[Task, WebSocketFrame] = Process.constant {
      case Text(t, _) => Task.delay( parse(t).toOption.foreach(msg => dispatcher.msgFromClient(msg)) )
    }

    //Get source of messages for client from the observer's process
    val source = observer.process.map(js => Text(js.noSpaces))

    Exchange(source, sink)
  }
}

