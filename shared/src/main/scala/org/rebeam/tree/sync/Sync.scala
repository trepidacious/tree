package org.rebeam.tree.sync

import io.circe._
import io.circe.generic.JsonCodec
import org.rebeam.tree.Delta

object Sync {

  /**
    * Globally unique identifier for a client (globally refers to the whole system under consideration -
    * may just be one server).
    * Assigned by server.
    *
    * @param id The identifier value
    */
  @JsonCodec
  case class ClientId(id: Long) extends AnyVal

  /**
    * Identifier for a delta, unique for a given client but not globally
    * Assigned by each client for deltas it generates.
    *
    * @param id The identifier value
    */
  @JsonCodec
  case class ClientDeltaId(id: Long) extends AnyVal {
    def next: ClientDeltaId = ClientDeltaId(id + 1)
  }

  /**
    * Identifier for a delta, globally unique (globally refers to the whole system under consideration -
    * may just be one server).
    *
    * @param clientId Client id
    * @param clientDeltaId Id of delta on that client
    */
  @JsonCodec
  case class DeltaId(clientId: ClientId, clientDeltaId: ClientDeltaId)

  /**
    * A delta and its id
    * @param delta  The Delta
    * @param id     The DeltaId of the Delta
    * @tparam A     The type of model the delta applies to
    */
  case class DeltaAndId[A](delta: Delta[A], id: DeltaId)

  /**
    * Globally likely-unique identifier for a model revision. This may be an actual guid, or a good
    * quality hash.
    *
    * @param id Identifier
    */
  @JsonCodec
  case class ModelId(id: Long) extends AnyVal

  /**
    * A model and its id
    * @param model  The model
    * @param id     The ModelId of the model
    * @tparam A     The type of the model
    */
  case class ModelAndId[A](model: A, id: ModelId)

  /**
    * Typeclass to generate a ModelId from a model. May provide
    * None if ModelId cannot be recreated from the model - e.g. if it
    * is not a hash but an incrementing index.
    * @tparam A     The type of the model
    */
  trait ModelIdGen[A] {
    def genId(model: A): Option[ModelId]
  }

  /**
    * A delta with an id and Json encoding
    * @param delta    The delta
    * @param id       The delta's id
    * @param deltaJs  The Json encoding of the delta
    * @tparam A       The type of model the delta applies to
    */
  case class DeltaWithIJ[A](delta: Delta[A], id: DeltaId, deltaJs: Json)

  // Client side


  /**
    * ADT for the two options we can receive from the server representing a delta in an update - either just a
    * DeltaId for a delta that came from this client, or a DeltaId and actual delta for a delta
    * generated by another client
    *
    * @tparam A The model type
    */
  sealed trait UpdateDelta[A] {
    def id: DeltaId
  }

  /**
    * A delta generated remotely, by another client, relayed to us by the server in an update
    *
    * @param delta The delta
    * @param id    The id of the delta
    * @tparam A The model type
    */
  case class RemoteDelta[A](delta: Delta[A], id: DeltaId) extends UpdateDelta[A]

  /**
    * A delta generated locally, by this client, then referenced by the server in an update
    *
    * @param id The id of the delta
    * @tparam A The model type
    */
  case class LocalDelta[A](id: DeltaId) extends UpdateDelta[A]

  /**
    * Sealed trait of model updates sent from server to client
    *
    * @tparam A The model type
    */
  sealed trait ModelUpdate[A]

  /**
    * An incremental update received from the server, building a new model based
    * on an existing base model assumed to be held by the client.
    *
    * @param baseModelId    The ModelId of the base model from which we will produce the updated model
    * @param updates        The updates to apply to the base model to produce the updated model
    * @param updatedModelId The ModelId of the updated model
    * @tparam A The type of model
    */
  case class ModelIncrementalUpdate[A](
                                        baseModelId: ModelId,
                                        updates: Seq[UpdateDelta[A]],
                                        updatedModelId: ModelId) extends ModelUpdate[A]

  /**
    * A full update received from server, directly setting a new model and overwriting
    * any pending deltas. The first update from the server must always be of this form.
    *
    * @param clientId The client id for the client. Sets id on first update, and
    *                 may be used to change client id on subsequent full updates.
    * @param model    The full model, and id
    * @tparam A The type of model
    */
  case class ModelFullUpdate[A](
                                 clientId: ClientId,
                                 model: ModelAndId[A]) extends ModelUpdate[A]


  def localDeltaDecoder[A]: Decoder[UpdateDelta[A]] =
    Decoder.instance(
      c => {
        val o = c.downField("local")
        for {
          id <- o.downField("id").as[DeltaId]
        } yield LocalDelta(id)
      }
    )

  def remoteDeltaDecoder[A](implicit dd: Decoder[Delta[A]]): Decoder[UpdateDelta[A]] =
    Decoder.instance(
      c => {
        val o = c.downField("remote")
        for {
          delta <- o.downField("delta").as[Delta[A]]
          id <- o.downField("id").as[DeltaId]
        } yield RemoteDelta(delta, id)
      }
    )

  def updateDeltaDecoder[A](implicit dd: Decoder[Delta[A]]): Decoder[UpdateDelta[A]] =
    localDeltaDecoder[A] or remoteDeltaDecoder[A]

  def fullUpdateDecoder[A](implicit d: Decoder[A]): Decoder[ModelUpdate[A]] =
    Decoder.instance(c => {
      val o = c.downField("full")
      for {
        clientId <- o.downField("clientId").as[ClientId]
        model <- o.downField("model").as[A]
        id <- o.downField("id").as[ModelId]
      } yield ModelFullUpdate[A](clientId, ModelAndId(model, id))
    })

  def incUpdateDecoder[A](implicit dd: Decoder[Delta[A]]): Decoder[ModelUpdate[A]] = {
    implicit val udd = updateDeltaDecoder[A](dd)
    Decoder.instance(c => {
      val o = c.downField("inc")
      for {
        baseModelId <- o.downField("baseModelId").as[ModelId]
        updatedModelId <- o.downField("updatedModelId").as[ModelId]
        deltas <- o.downField("updates").as[Vector[UpdateDelta[A]]]
      } yield ModelIncrementalUpdate[A](baseModelId, Vector(), updatedModelId)
    })
  }

  def updateDecoder[A](implicit d: Decoder[A], dd: Decoder[Delta[A]]): Decoder[ModelUpdate[A]] =
    fullUpdateDecoder[A] or incUpdateDecoder[A]

}
