package org.rebeam.tree.logoot

import org.rebeam.tree.Delta.DeltaIO
import org.rebeam.tree.{DeltaIOContext, Moment}
import org.rebeam.tree.logoot.Logoot._
import org.rebeam.tree.sync.DeltaIORun
import org.rebeam.tree.sync.Sync._
import org.scalatest._
import org.scalatest.prop.Checkers
import org.scalacheck.Arbitrary._
import org.scalacheck.{Arbitrary, Gen}
import org.scalacheck.Prop._
import org.scalacheck.Gen._

import scala.collection.mutable.ListBuffer

class LogootSpec extends WordSpec with Matchers with Checkers {

  def assertCompare[A: Ordering](a: A, b: A, result: Int): Unit =
    assert(implicitly[Ordering[A]].compare(a, b) == result, s" - expected $a compare $b to be $result")
  def assertLessThan[A: Ordering](a: A, b: A): Unit = assertCompare(a, b, -1)
  def assertMoreThan[A: Ordering](a: A, b: A): Unit = assertCompare(a, b, 1)
  def assertSame[A: Ordering](a: A, b: A): Unit = assertCompare(a, b, 0)

  val identifierTests: List[(Identifier, Identifier, Int)] = List(
    // Same
    ( Identifier(0, ClientId(0)),
      Identifier(0, ClientId(0)), 0),

    ( Identifier(1, ClientId(1)),
      Identifier(1, ClientId(1)), 0),

    // Differ in pos, not in client
    ( Identifier(0, ClientId(0)),
      Identifier(1, ClientId(0)), -1),

    ( Identifier(1, ClientId(0)),
      Identifier(0, ClientId(0)), 1),

    // Differ in pos, client differs the other way
    ( Identifier(0, ClientId(1)),
      Identifier(1, ClientId(0)), -1),

    ( Identifier(1, ClientId(0)),
      Identifier(0, ClientId(1)), 1),

    // Same in pos, differ in client
    ( Identifier(0, ClientId(0)),
      Identifier(0, ClientId(1)), -1),

    ( Identifier(0, ClientId(1)),
      Identifier(0, ClientId(0)), 1)
  )

  val deltaContext = DeltaIOContext(Moment(0))
  val deltaId = DeltaId(ClientId(99), ClientDeltaId(999))

  def run[A](d: DeltaIO[A]): A = DeltaIORun.runDeltaIO(d, deltaContext, deltaId).data

  def validIdentifier(p: Int, c: Int, last: Boolean): Identifier = {

    def validPos(x: Int): Int = {
      val abs = Math.abs(x)
      val min = if (last) 1 else 0  // Note we still need to check against 0 even after abs,
                                    // abs(Int min value) is still negative.
      if (abs < min) min else abs
    }

    Identifier(validPos(p), ClientId(c))
  }

  implicit val pairGen: Gen[(Int, Int)] = implicitly[Arbitrary[(Int, Int)]].arbitrary

  // We ensure that the last identifier in any position generated by positionBetween (and
  // hence any position in a sequence) has a pos > 0. This is required by the algorithm,
  // and guaranteed by its output.
  // Therefore we enforce this invariant in arbitrary positions.
  implicit val arbitraryPosition: Arbitrary[Position] = Arbitrary(
    for {
      l <- Gen.resize(64, listOf[(Int, Int)](pairGen))
      lastPair <- pairGen
    } yield {
      l.map{case (p, c) => validIdentifier(p, c, false)} :+ validIdentifier(lastPair._1, lastPair._2, true)
    }
  )

  "Logoot" should {
    "compare identifiers" in {
      for (t <- identifierTests) assertCompare(t._1, t._2, t._3)

    }
    "compare positions" in {
      // Positions with a single identifier compare as per identifier
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2), t._3)

      val extraId = Identifier(2, ClientId(0))

      // Positions with different lengths compare by identifiers then by length
      for (t <- identifierTests) assertCompare(List(t._1), List(t._2, extraId), if (t._3 != 0) t._3 else -1)
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2), if (t._3 != 0) t._3 else 1)

      // Adding another equal element gives same comparison
      for (t <- identifierTests) assertCompare(List(t._1, extraId), List(t._2, extraId), t._3)

      // Empty position is less than any non-empty position
      assertSame(Position.empty, Position.empty)
      for (t <- identifierTests) {
        assertLessThan(Position.empty, List(t._1))
        assertLessThan(Position.empty, List(t._2))
      }

      //Check two positions where one is a prefix of the other
      val p = List(
        Identifier(1, ClientId(0)),
        Identifier(1, ClientId(0)),
        Identifier(2, ClientId(0)),
        Identifier(3, ClientId(0)),
        Identifier(4, ClientId(0)),
        Identifier(5, ClientId(0)),
        Identifier(6, ClientId(0)),
        Identifier(7, ClientId(0))
      )
      val q = List(
        Identifier(1, ClientId(0)),
        Identifier(1, ClientId(0)),
        Identifier(2, ClientId(0)),
        Identifier(3, ClientId(0)),
        Identifier(4, ClientId(0)),
        Identifier(5, ClientId(0)),
        Identifier(6, ClientId(0)),
        Identifier(7, ClientId(0)),
        Identifier(8, ClientId(0))
      )
      assertLessThan(p, q)

    }

    "construct positions between other positions" in {

//      val p = Position(List(          //01
//        Identifier(0, ClientId(0)),
//        Identifier(1, ClientId(1))
//      ))
//      val q = Position(List(          //02
//        Identifier(0, ClientId(2)),
//        Identifier(2, ClientId(3))
//      ))
//      val r = Position(List(          //03
//        Identifier(0, ClientId(4)),
//        Identifier(3, ClientId(5))
//      ))
//
//      // There are no 2 digit positions between p and q, so we end up
//      // adding a new digit, at 1
//      assert (
//        run(Position.between(p, q, 1))
//          ===
//        List(
//          Position(List(
//            Identifier(0,ClientId(0)),
//            Identifier(1,ClientId(1)),
//            Identifier(1,ClientId(99))
//          ))
//        )
//      )
//
//      // There is a single 1 digit position between p and r, 02
//      assert (
//        run(Position.between(p, r, 1))
//          ===
//          List(
//            Position(List(
//              Identifier(0,ClientId(0)),
//              Identifier(2,ClientId(99))
//            ))
//          )
//      )
//
//      val s = Position(List(          //06
//        Identifier(0, ClientId(6)),
//        Identifier(6, ClientId(7))
//      ))
//
//      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 4
//      // Will use a step of 1, giving exactly each code
//      assert(
//        run(Position.between(p, s, 4))
//          ===
//        List(
//          Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)))),    //02
//          Position(List(Identifier(0,ClientId(0)), Identifier(3,ClientId(99)))),    //03
//          Position(List(Identifier(0,ClientId(0)), Identifier(4,ClientId(99)))),    //04
//          Position(List(Identifier(0,ClientId(0)), Identifier(5,ClientId(99))))     //05
//        )
//      )
//
//      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 3
//      // 3 codes from 4 options means step size 1, so we get the first 3 options
//      assert(
//        run(Position.between(p, s, 3))
//          ===
//          List(
//            Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)))),    //02
//            Position(List(Identifier(0,ClientId(0)), Identifier(3,ClientId(99)))),    //03
//            Position(List(Identifier(0,ClientId(0)), Identifier(4,ClientId(99))))    //04
//          )
//      )
//
//      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 2
//      // 2 codes from 4 options means step size 2, so we get the 1st and 3rd option
//      assert(
//        run(Position.between(p, s, 2))
//          ===
//          List(
//            Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)))),    //02
//            Position(List(Identifier(0,ClientId(0)), Identifier(4,ClientId(99))))    //04
//          )
//      )
//
//      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 1
//      // 1 codes from 4 options means step size 4, so we get the 1st option only
//      assert(
//        run(Position.between(p, s, 1))
//          ===
//          List(
//            Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99))))    //02
//          )
//      )
//
//
//      // Test a gap for 4 new 2 digit codes (from 01 to 06), requesting 5
//      // We therefore require more digits.
//      // Considered as 3 digit codes, 060 - 010 is 5 * base = 5 * 2147483648 = 10737418240
//      // This gives 10737418240 - 1 = 10737418239 options, divided by 5 requested codes
//      // gives a window of 2147483647.8, rounded down to 2147483647 for each code.
//      // The first code is always at + 1, so we go from 01 to 011,
//      // then each subsequent code is at i steps of 2147483647 from this.
//      // 2147483647 is the base - 1, the maximum int value m, so we get 011, then 020, then 02m, then 03(m-1) and so on
//      assert(
//        run(Position.between(p, s, 5))
//          ===
//        List(
//          Position(List(Identifier(0,ClientId(0)), Identifier(1,ClientId(1)), Identifier(1,ClientId(99)))),           //011
//          Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)), Identifier(0,ClientId(99)))),          //020
//          Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)), Identifier(2147483647,ClientId(99)))), //02m
//          Position(List(Identifier(0,ClientId(0)), Identifier(3,ClientId(99)), Identifier(2147483646,ClientId(99)))), //03(m-1)
//          Position(List(Identifier(0,ClientId(0)), Identifier(4,ClientId(99)), Identifier(2147483645,ClientId(99))))  //04(m-2)
//        )
//      )
//
//      // Test a gap for 1 2-digit code (01 to 03), when requesting 2
//      // We again require more digits, and get 030-010 = 2 * base,
//      // and so 2 * base - 1 = 4294967295 options. Divided by 2 code
//      // we get 2147483647.5 rounding down to 2147483647, so as above
//      // we get 011 then 020
//      assert (
//        run(Position.between(p, r, 2))
//          ===
//        List(
//          Position(List(Identifier(0,ClientId(0)), Identifier(1,ClientId(1)), Identifier(1,ClientId(99)))), //011
//          Position(List(Identifier(0,ClientId(0)), Identifier(2,ClientId(99)), Identifier(0,ClientId(99)))) //020
//        )
//      )
//
//      val p = Position(List(
//        Identifier(1, ClientId(0)),
//        Identifier(1, ClientId(1)),
//        Identifier(2, ClientId(2)),
//        Identifier(3, ClientId(3)),
//        Identifier(4, ClientId(4)),
//        Identifier(5, ClientId(5)),
//        Identifier(6, ClientId(6)),
//        Identifier(7, ClientId(7))
//      ))
//      val q = Position(List(
//        Identifier(1, ClientId(8)),
//        Identifier(1, ClientId(9)),
//        Identifier(2, ClientId(10)),
//        Identifier(3, ClientId(11)),
//        Identifier(4, ClientId(12)),
//        Identifier(5, ClientId(13)),
//        Identifier(6, ClientId(14)),
//        Identifier(7, ClientId(15)),
//        Identifier(8, ClientId(16))
//      ))
////      run(Position.between(q, p, 2))
//      println(s"$p compare to $q is ${Logoot.positionOrdering.compare(p, q)}")
    }

    "construct valid positions between other positions" in {

      // We wouldn't normally have an empty position, but it should work
      val p = Position.empty
      val q = List(Identifier(1, ClientId(0)))

      assert (
        run(Position.between(p, q))
          ===
        List(Identifier(0,ClientId(0)), Identifier(1,ClientId(99)))
      )

      //Some cases that failed on early implementation with scalacheck

      // An interesting one where we have p < q because of the first ident, but no gap
      // between p and q, so we move to the second ident, where p's ident is > q's ident.
      // This isn't actually an error - we are free to choose any ident > p's ident - the
      // second ident from q doesn't matter since after we incorporate the first ident from
      // p into the result we cannot be > q regardless of subsequent idents.
      assert (
        run(Position.between(
          List(Identifier(0,ClientId(0)), Identifier(1692726032,ClientId(0)), Identifier(1,ClientId(0))),
          List(Identifier(1,ClientId(0)), Identifier(109895862,ClientId(0)))
        ))
          ===
        List(Identifier(0,ClientId(0)), Identifier(1692726033,ClientId(99)))
      )

      // This is an example of a pair that breaks if we permit identifiers that are less than
      // Logoot.firstPosition's identifier (the padding identifier) - the 0 (minimum) pos and
      // negative client id mean that the second ident in q is lower than the padding identifier,
      // and so when we move past this ident by adding padding we actually produce a new
      // position above q.
//          List(),
//          List(Identifier(0,ClientId(0)), Identifier(0,ClientId(-1328222)))

      //TODO a test case for each of the paths through positionBetweenRec
    }

    "construct valid positions between arbitrary other positions" in {
      check((a: Position, b: Position) => {

        def test(p: Position, q: Position): Boolean = {
          try {

//            println(s"Inserting ${n.i} positions, p $p, q $q")

            val po = Logoot.positionOrdering
            val r = run(Position.between(p, q))

            // Position must be strictly between p and q
            val afterP = po.compare(p, r) == -1
            val beforeQ = po.compare(r, q) == -1

            //println(s"p = $p, q = $q, r = $r")
            //println(s"afterP $afterP, beforeQ $beforeQ")

            afterP && beforeQ

          // Workaround for not being able to set scalacheck verbosity for some reason...
          // See https://stackoverflow.com/questions/24396407/how-to-display-entire-stack-trace-for-thrown-exceptions-from-scalacheck-tests
          } catch {
            case t: Throwable =>
              println("Failed to generate positions:")
              t.printStackTrace()
              false
          }

        }

        Logoot.positionOrdering.compare(a, b) match {
          case 0 => true
          case -1 => test(a, b)
          case _ => test(b, a)
        }
      }, MinSuccessful(100000))
    }

  }

}
